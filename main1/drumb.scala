// Main Part 1 about a really dumb investment strategy
//===================================================

object M1 {

//two test portfolios

val blchip_portfolio = List("GOOG", "AAPL", "MSFT", "IBM", "FB", "AMZN", "BIDU")
val rstate_portfolio = List("PLD", "PSA", "AMT", "AIV", "AVB", "BXP", "CCI", 
                            "DLR", "EQIX", "EQR", "ESS", "EXR", "FRT", "HCP") 


// (1) The function below takes a stock symbol and a year as arguments.
//     It should read the corresponding CSV-file and then extract the January 
//     data from the given year. The data should be collected in a list of
//     strings (one entry for each line in the CSV-file).


import io.Source
import scala.util._

def get_january_data(symbol: String, year: Int) : List[String] = {
    val bufferedSource = Try(Some(Source.fromFile(symbol + ".csv"))).getOrElse(None)
    if(bufferedSource.isDefined) {
        val allDataLines = bufferedSource.get.getLines().drop(1).toList
        bufferedSource.get.close
        allDataLines.filter(line => line.startsWith(year.toString))
    }
    else {
        Nil
    }
}


// (2) From the output of the get_january_data function, the next function 
//     should extract the first line (if it exists) and the corresponding
//     first trading price in that year with type Option[Double]. If no line 
//     is generated by get_january_data then the result is None; and Some if 
//     there is a price.


def get_first_price(symbol: String, year: Int) : Option[Double] = get_january_data(symbol, year) match {
    case Nil => None
    case head :: tail => {
        val data = head.split(",").map(_.trim)
        Some(data(1).toDouble)
    }
}


// (3) Complete the function below that obtains all first prices
//     for the stock symbols from a portfolio (list of strings) and 
//     for the given range of years. The inner lists are for the
//     stock symbols and the outer list for the years.


def get_prices(portfolio: List[String], years: Range) : List[List[Option[Double]]] = {
    (for (year <- years) yield (for (symbol <- portfolio) yield (get_first_price(symbol, year)))).toList
}



// (4) The function below calculates the change factor (delta) between
//     a price in year n and a price in year n + 1. 

def get_delta(price_old: Option[Double], price_new: Option[Double]) : Option[Double] = {
    if(price_old != None && price_new != None) {
        Some((price_new.get - price_old.get) / price_old.get)
    }
    else {
        None
    }
}



// (5) The next function calculates all change factors for all prices (from a 
//     portfolio). The input to this function are the nested lists created by 
//     get_prices above.

// List(List(Some(312.204773), Some(26.782711)), List(Some(301.0466), Some(41.244694)), List(Some(331.462585), Some(51.464207)))
// get_deltas(get_prices(List("GOOG", "AAPL"), (2010 to 2012)))

def get_deltas_sublist(old: List[Option[Double]], neww: List[Option[Double]], numberOfCompanies: Int): List[List[Option[Double]]] = {
    List((for(n <- (0 until numberOfCompanies)) yield (get_delta(old(n), neww(n)))).toList)
}

def get_deltas_recursively(data: List[List[Option[Double]]], result: List[List[Option[Double]]] = Nil) :  List[List[Option[Double]]] = data match {
    case Nil => result
    case head :: tail =>if(tail != Nil) {
                            get_deltas_recursively(data.takeRight(data.length - 1) , result ::: get_deltas_sublist(head, tail.head, head.length))
                        }
                        else {
                            result
                        }
}

def get_deltas(data: List[List[Option[Double]]]) :  List[List[Option[Double]]] = get_deltas_recursively(data)


// (6) Write a function that given change factors, a starting balance and an index, 
//     calculates the yearly yield, i.e. new balance, according to our dumb investment 
//     strategy. Index points to a year in the data list.

// List(List(Some(-0.03573991804411003), Some(0.539974575389325)), List(Some(0.10103414222249969), Some(0.24777764141006836)))

def yearly_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = {

    val temp = data(index).flatten
    val numberOfCompanies = temp.length
    if(numberOfCompanies == 0) {
        0
    }
    else {
        val investInEach = (balance / numberOfCompanies).toDouble
        val lst = for(n <- (0 until numberOfCompanies)) yield investInEach * temp(n)
        lst.sum.toLong + balance
    }
}


// (7) Write a function compound_yield that calculates the overall balance for a 
//     range of years where in each year the yearly profit is compounded to the new 
//     balances and then re-invested into our portfolio. For this use the function and 
//     results generated under (6). The function investment calls compound_yield
//     with the appropriate deltas and the first index.


def compound_yield_recursively(data: List[List[Option[Double]]], balance: Long, index: Int) :  Long = data match {
    case Nil => balance
    case head :: tail =>if(tail != Nil) {
                            compound_yield_recursively(data.takeRight(data.length - 1) , (yearly_yield(List(head), balance, index)), 0)
                        }
                        else {
                            yearly_yield(List(head), balance, index)
                        }
}

def compound_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = compound_yield_recursively(data, balance, index)

def investment(portfolio: List[String], years: Range, start_balance: Long) : Long = compound_yield(get_deltas(get_prices(portfolio, years)), start_balance, 0)

//Test cases for the two portfolios given above

//println("Real data: " + investment(rstate_portfolio, 1978 to 2019, 100))
//println("Blue data: " + investment(blchip_portfolio, 1978 to 2019, 100))


}